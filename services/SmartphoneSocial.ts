
import { Contact } from "./smartphoneStorage";

export interface SocialComment {
    id: string;
    authorId: string;
    authorName: string;
    content: string;
    timestamp: number;
}

export interface SocialPost {
    id: string;
    authorId: string; // Contact ID or 'user' or 'system_npc'
    authorName: string;
    authorHandle: string; // @username
    authorAvatar: string;
    content: string;
    image?: string;
    likes: number;
    isLiked: boolean;
    timestamp: number;
    comments: SocialComment[];
    tags?: string[];
}

export interface PendingReply {
    id: string;
    postId: string;
    targetTime: number; // Kapan reply ini harus muncul (Virtual Time)
    authorName: string; // Siapa yang membalas (Author Post)
    userComment: string; // Komentar user yang dibalas
    postContent: string; // Konteks post
}

export interface SocialData {
    posts: SocialPost[];
    userHandle: string;
    lastFetch: number; // Virtual Time terakhir fetch
    lastRealReset: number; // Real Time terakhir reset (2 jam sekali)
    pendingReplies: PendingReply[]; // Antrean balasan
}

export const SOCIAL_STORAGE_KEY = 'pasco_social_storage_v1';
const REAL_RESET_INTERVAL = 2 * 60 * 60 * 1000; // 2 Jam Real Time

// --- INITIAL DATA GENERATOR ---
// Only Admin post remains. The rest will be generated by AI from contacts.
const generateInitialPosts = (virtualTime: number): SocialPost[] => [
    {
        id: 'post_init_1',
        authorId: 'system_admin',
        authorName: 'Connected Admin',
        authorHandle: '@admin',
        authorAvatar: 'https://api.dicebear.com/7.x/shapes/svg?seed=Admin',
        content: 'Selamat datang di Connected! Hubungkan pikiranmu dengan orang-orang terdekat. ðŸŒ #welcome',
        likes: 1024,
        isLiked: false,
        timestamp: virtualTime - 86400000,
        comments: []
    }
];

// --- PUBLIC API ---

export const getSocialData = (characterId: string): SocialData => {
    try {
        const store = localStorage.getItem(SOCIAL_STORAGE_KEY);
        const parsed = store ? JSON.parse(store) : {};
        
        let data = parsed[characterId];

        // Init if empty
        if (!data) {
            data = {
                posts: generateInitialPosts(Date.now()),
                userHandle: '@user',
                lastFetch: 0,
                lastRealReset: Date.now(),
                pendingReplies: []
            };
            saveSocialData(characterId, data);
        }

        return data;
    } catch (e) {
        console.error("Social storage read error", e);
        return { posts: [], userHandle: '@user', lastFetch: 0, lastRealReset: Date.now(), pendingReplies: [] };
    }
};

export const saveSocialData = (characterId: string, data: SocialData) => {
    try {
        const store = localStorage.getItem(SOCIAL_STORAGE_KEY);
        const parsed = store ? JSON.parse(store) : {};
        parsed[characterId] = data;
        localStorage.setItem(SOCIAL_STORAGE_KEY, JSON.stringify(parsed));
    } catch (e) {
        console.error("Social storage write error", e);
    }
};

// --- ACTIONS ---

export const socialCheckReset = (characterId: string): boolean => {
    const data = getSocialData(characterId);
    const now = Date.now();

    // Cek apakah sudah 2 jam Real Time sejak reset terakhir
    if (now - data.lastRealReset > REAL_RESET_INTERVAL) {
        data.posts = generateInitialPosts(now); // Reset posts
        data.lastRealReset = now;
        data.lastFetch = 0; // Reset fetch counter
        data.pendingReplies = []; // Clear pending
        saveSocialData(characterId, data);
        return true; // Reset occurred
    }
    return false;
};

export const socialToggleLike = (characterId: string, postId: string) => {
    const data = getSocialData(characterId);
    const postIndex = data.posts.findIndex(p => p.id === postId);
    if (postIndex !== -1) {
        const post = data.posts[postIndex];
        post.isLiked = !post.isLiked;
        post.likes = post.isLiked ? post.likes + 1 : post.likes - 1;
        data.posts[postIndex] = post;
        saveSocialData(characterId, data);
    }
    return data;
};

export const socialAddComment = (characterId: string, postId: string, text: string, authorName: string = 'You', virtualTime: number) => {
    const data = getSocialData(characterId);
    const postIndex = data.posts.findIndex(p => p.id === postId);
    
    if (postIndex !== -1) {
        const post = data.posts[postIndex];
        
        // 1. Add User Comment
        const newComment: SocialComment = {
            id: crypto.randomUUID(),
            authorId: 'user',
            authorName: authorName,
            content: text,
            timestamp: virtualTime
        };
        post.comments.push(newComment);

        // 2. Schedule AI Reply (Random 3-60 mins in-game)
        // Only if author is NOT user
        if (post.authorId !== 'user') {
            const delayMinutes = Math.floor(Math.random() * (60 - 3 + 1)) + 3;
            const targetTime = virtualTime + (delayMinutes * 60 * 1000);
            
            data.pendingReplies.push({
                id: crypto.randomUUID(),
                postId: post.id,
                targetTime: targetTime,
                authorName: post.authorName, // The post author replies
                userComment: text,
                postContent: post.content
            });
        }

        saveSocialData(characterId, data);
    }
    return data;
};

export const socialCreatePost = (characterId: string, content: string, image?: string) => {
    const data = getSocialData(characterId);
    const newPost: SocialPost = {
        id: crypto.randomUUID(),
        authorId: 'user',
        authorName: 'You',
        authorHandle: data.userHandle,
        authorAvatar: 'https://api.dicebear.com/7.x/micah/svg?seed=User&backgroundColor=e2e8f0',
        content: content,
        image: image,
        likes: 0,
        isLiked: false,
        timestamp: Date.now(), // Use real time or passed virtual time? Ideally virtual.
        comments: []
    };
    // Add to top
    data.posts.unshift(newPost);
    saveSocialData(characterId, data);
    return data;
};

export const socialAppendPosts = (characterId: string, newPosts: SocialPost[]) => {
    const data = getSocialData(characterId);
    // Filter duplicates based on ID or content similarity to be safe
    const uniquePosts = newPosts.filter(p => !data.posts.some(existing => existing.id === p.id));
    
    // Append to bottom
    data.posts = [...data.posts, ...uniquePosts];
    saveSocialData(characterId, data);
    return data;
};

export const socialProcessReplies = (characterId: string, generatedText: string, replyId: string) => {
    const data = getSocialData(characterId);
    const replyIdx = data.pendingReplies.findIndex(r => r.id === replyId);
    
    if (replyIdx !== -1) {
        const replyMeta = data.pendingReplies[replyIdx];
        const postIndex = data.posts.findIndex(p => p.id === replyMeta.postId);
        
        if (postIndex !== -1) {
            const aiReply: SocialComment = {
                id: crypto.randomUUID(),
                authorId: data.posts[postIndex].authorId,
                authorName: replyMeta.authorName,
                content: generatedText,
                timestamp: replyMeta.targetTime
            };
            data.posts[postIndex].comments.push(aiReply);
        }
        
        // Remove from pending
        data.pendingReplies.splice(replyIdx, 1);
        saveSocialData(characterId, data);
    }
    return data;
};
